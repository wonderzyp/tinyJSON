使用时，先将输入的字符串形式`const char* `的json文本复制一份副本存入c.json中，再针对c.json进行解析

解析调用`lept_parse_value`函数，解析成功会返回`LEPT_PARSE_OK`

单元测试
---
一般软件开发以周期进行，加入功能再写该功能的单元测试
另一种软件开发方法论：测试驱动开发(TDD, test-driven development)，先写测试再编写实现代码，直到通过所有测试

解析器
---
传入的JSON文本是一个C字符串，不会对其进行操作，声明为`const char*`类型
为减少解析函数之间传递多个参数，将数据均放进一个结构体

断言(assertion)
---
C语言中常见的防御式编程方式，可减少错误
- 函数开始阶段：检测所有参数
- 调用函数后：检查上下文是否正确

C语言包含`assert()`宏，提供断言功能
release模式编译时，由于定义了`NDEBUG`，不会对`assert`进行检测
debug模式则会检测条件是否为真
> 注意release和debug模式行为可能不一致，使用断言需避免副作用

错误由程序员错误编码引起，使用断言
运行环境引起（打开文件失败等），处理运行时错误（抛出异常等）

Union
---
节省空间，但调用时可能显得很长
C11引入匿名Union

使用`#ifndef X #define X ... #endif`：使用者可在编译选项中自设置宏值，未设置则使用缺省值



解析数组
---
解析数组的关键是内存管理
#### 数据结构的选择
数组：
- 优：O(1)访问任意元素，内存紧凑且高速缓存一致性(cache coherence)
- 缺：无法快速插入元素，不确定分配多大内存

链表：
- 优：可快速插入，但索引元素O(n)
- 缺：额外内存开销（指向下一个元素的指针），内存不连续导致缓存不命中(cache miss)


#### 堆栈的压入压出
按字节存储，每次可压入任意大小数据，返回数据的**起始指针**

指向void*的指针
---
一个指向任何对象类型的指针均可赋值给类型为`void*`的变量
用途：
1. 从函数返回一个无类型对象，使用时需进行显式的类型转换
2. 需向函数传递指针，且不能对对象类型做假设

对于数据的元素释放，需将数组内的元素递归调用`lept_free()`，再释放本身的`v->u.a.e`



返回指针的生命周期
---
```c
for (;;) {
    /* bug! */
    lept_value* e = lept_context_push(c, sizeof(lept_value));
    lept_init(e);
    size++;
    if ((ret = lept_parse_value(c, e)) != LEPT_PARSE_OK)
        return ret;
    /* ... */
}
```
`lept_parse_value`及以下的函数均会调用`lept_context_push`函数，可能调用`realloc()`导致最上层的指针`lept_value* e`失效，变为悬挂指针(dangling pointer)
> 悬挂指针指向非法的内存地址，无法正常使用的指针

同理，使用C++容器时，取得迭代器后，若改动容器内容，会导致之前的迭代器失效

此类bug不易察觉，一般在堆栈满时发生，因此需要压力测试

因此需谨慎考虑变量周期（尤其是指针）

解析对象部分
---
重构：提取方法(extract method)
原本的解析字符串函数，将字符串解析后直接写入lept_value
但由于我们只需要解析字符串的功能，因此将原有函数拆分为**解析**与**写入**


动态栈的理解：
---
```c
typedef struct {
    const char* json;
    char* stack;
    size_t size, top;
}lept_context;
```
仅`lept_context_push`和`..._pop`使用动态栈
`static void* lept_context_push(lept_context* c, size_t size)`向`c`的栈中压入大小为size的内容，内存不够时以1.5倍放大
返回的是当前栈已使用空间的顶点（**不是容量的顶点**）
使用时需调用`memcpy`函数


生成器
---
解析器：将JSON文本解析为一个树形数据结构
生成器：将树形数据结构转换为JSON文本

需借助堆栈保存临时的解析结果，作为输出缓冲区

凡涉及赋值，均存在资源所有权的问题
一个值s，不能简单以指针的方式写入对象v，如此两个地方均拥有s
这样会导致重复释放的bug
方案1：深度复制
方案2：将参数的拥有权转移至新增键值对，再将`value`设置为null，即移动语义`move semantics`

定长数组在增删元素时，需重新分配数组，O(n2)的时间复杂度
动态数组可解决此问题


